<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"ccm.js.html":{"id":"ccm.js.html","title":"Source: ccm.js","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Source: ccm.js \"use strict\"; /** * @overview * Creates the global namespace [window.ccm]{@link ccm}. * @author André Kless &lt;andre.kless@web.de&gt; (https://github.com/akless) 2014-2023 * @license The MIT License (MIT) * @version 28.0.0 * @changes * Version 28.0.0 * - ccm.load: resource data is no longer cloned * - ccm.load: removed timeout for loading resources * - ccm.load: JSON is loaded either via fetch API or JSONP (no longer via XMLHttpRequest) * - ccm.load: used HTTP method must be in upper case * - ccm.load: simplified error messages * - ccm.helper.html: dynamic parameters must be passed via an object */ (() =&gt; { /** * Encapsulates everything related to _ccmjs_. * See [this wiki]{@link https://github.com/ccmjs/framework/wiki/} to learn everything about this web technology. * @global * @namespace */ const ccm = { /** * @description Returns the _ccmjs_ framework version. * @returns {ccm.types.version_nr} */ version: () =&gt; \"28.0.0\", /** * @summary Asynchronous Loading of Resources * @description See [this wiki page]{@link https://github.com/ccmjs/framework/wiki/Loading-of-Resources} to learn everything about this method. There are also examples how to use it. * @param {...(string|ccm.types.resource_obj)} resources - Resources to load. Either the URL or a [resource object]{@link ccm.types.resource_obj} can be passed for a resource. * @returns {Promise&lt;*&gt;} */ load: async (...resources) =&gt; { let results = []; let counter = 1; let failed = false; return new Promise((resolve, reject) =&gt; { resources.forEach((resource, i) =&gt; { counter++; if (Array.isArray(resource)) { results[i] = []; serial(null); return; } if (typeof resource === \"string\") resource = { url: resource }; if (!resource.context) resource.context = document.head; if (ccm.helper.isInstance(resource.context)) resource.context = resource.context.element.parentNode; getOperation()(); function serial(result) { if (result !== null) results[i].push(result); if (!resource.length) return check(); let next = resource.shift(); if (!Array.isArray(next)) next = [next]; ccm.load.apply(null, next).then(serial).catch(serial); } function getOperation() { switch (resource.type) { case \"html\": return loadHTML; case \"css\": return loadCSS; case \"image\": return loadImage; case \"js\": return loadJS; case \"module\": return loadModule; case \"json\": return loadJSON; case \"xml\": return loadXML; } const suffix = resource.url .split(\"?\") .shift() .split(\"#\") .shift() .split(\".\") .pop() .toLowerCase(); switch (suffix) { case \"html\": return loadHTML; case \"css\": return loadCSS; case \"jpg\": case \"jpeg\": case \"gif\": case \"png\": case \"svg\": case \"bmp\": return loadImage; case \"js\": return loadJS; case \"mjs\": return loadModule; case \"xml\": return loadXML; default: return loadJSON; } } function loadHTML() { resource.type = \"html\"; loadJSON(); } function loadCSS() { let element = { tag: \"link\", rel: \"stylesheet\", type: \"text/css\", href: resource.url, }; if (resource.attr) element = Object.assign(element, resource.attr); element = ccm.helper.html(element); element.onload = () =&gt; success(resource.url); element.onerror = error; resource.context.appendChild(element); } function loadImage() { const image = new Image(); image.src = resource.url; image.onload = () =&gt; success(resource.url); image.onerror = error; } function loadJS() { const filename = resource.url .split(\"/\") .pop() .split(\"?\") .shift() .replace(\".min.\", \".\"); window.ccm.files[filename] = null; window.ccm.files[\"#\" + filename] = window.ccm.files[\"#\" + filename] ? window.ccm.files[\"#\" + filename] + 1 : 1; let element = { tag: \"script\", src: resource.url, async: true }; if (resource.attr) element = Object.assign(element, resource.attr); element = ccm.helper.html(element); element.onload = () =&gt; { const data = window.ccm.files[filename]; if (!--window.ccm.files[\"#\" + filename]) { delete window.ccm.files[filename]; delete window.ccm.files[\"#\" + filename]; } element.parentNode.removeChild(element); success(data); }; element.onerror = () =&gt; { element.parentNode.removeChild(element); error(); }; resource.context.appendChild(element); } function loadModule() { let [url, ...keys] = resource.url.split(\"#\"); if (url.startsWith(\"./\")) url = url.replace( \"./\", location.href.substring(0, location.href.lastIndexOf(\"/\") + 1), ); import(url).then((result) =&gt; { if (keys.length === 1) result = ccm.helper.deepValue(result, keys[0]); if (keys.length &gt; 1) { const obj = {}; keys.forEach((key) =&gt; (obj[key] = result[key])); result = obj; } success(result); }); } function loadJSON() { (resource.method === \"JSONP\" ? jsonp : fetchAPI)(); function jsonp() { const callback = \"callback\" + ccm.helper.generateKey(); if (!resource.params) resource.params = {}; resource.params.callback = \"window.ccm.callbacks.\" + callback; let element = { tag: \"script\", src: buildURL(resource.url, resource.params), }; if (resource.attr) element = Object.assign(element, resource.attr); element = ccm.helper.html(element); element.onerror = () =&gt; { element.parentNode.removeChild(element); error(); }; window.ccm.callbacks[callback] = (data) =&gt; { element.parentNode.removeChild(element); delete window.ccm.callbacks[callback]; success(data); }; resource.context.appendChild(script); } function fetchAPI() { if (resource.params) resource.method === \"GET\" ? (resource.url = buildURL(resource.url, resource.params)) : (resource.body = ccm.helper.stringify(resource.params)); fetch(resource.url, { ...resource }) .then((response) =&gt; response.text()) .then(success) .catch(error); } function buildURL(url, data) { if (ccm.helper.isObject(data.json)) data.json = ccm.helper.stringify(data.json); return data ? url + \"?\" + params(data).slice(0, -1) : url; function params(obj, prefix) { let result = \"\"; for (const i in obj) { const key = prefix ? prefix + \"[\" + encodeURIComponent(i) + \"]\" : encodeURIComponent(i); if (typeof obj[i] === \"object\") result += params(obj[i], key); else result += key + \"=\" + encodeURIComponent(obj[i]) + \"&amp;\"; } return result; } } } function loadXML() { resource.type = \"xml\"; loadJSON(); } function success(data) { if (data === undefined) return check(); try { if (typeof data !== \"object\") data = ccm.helper.parse(data); } catch (e) {} if (resource.type === \"html\") { const regex = /&lt;ccm-template key=\"(\\w*?)\"&gt;([^]*?)&lt;\\/ccm-template&gt;/g; const result = {}; let array; while ((array = regex.exec(data))) result[array[1]] = array[2]; if (Object.keys(result).length) data = result; } if (resource.type === \"xml\") data = new window.DOMParser().parseFromString(data, \"text/xml\"); results[i] = data; check(); } function error() { failed = true; results[i] = Error(`loading of ${resource.url} failed`); check(); } }); check(); function check() { if (--counter) return; if (results.length &lt;= 1) results = results[0]; (failed ? reject : resolve)(results); } }); }, /** * @description * Contains framework-relevant helper functions. * These are also useful for component developers. * @namespace */ helper: { /** * @description Compares two version numbers. * @param {ccm.types.version_nr} a - 1st version number * @param {ccm.types.version_nr} b - 2nd version number * @returns {number} -1: a &lt; b, 0: a = b, 1: a &gt; b * @example console.log( compareVersions( '3.0.0', '2.10.0' ) ); // =&gt; 1 * @example console.log( compareVersions( '8.0.1', '8.0.10' ) ); // =&gt; -1 */ compareVersions: (a, b) =&gt; { if (a === b) return 0; if (!a) return a; if (!b) return b; const a_arr = a.split(\".\"); const b_arr = b.split(\".\"); for (let i = 0; i &lt; 3; i++) { const x = parseInt(a_arr[i]); const y = parseInt(b_arr[i]); if (x &lt; y) return -1; else if (x &gt; y) return 1; } return 0; }, /** * @description Returns or modifies a value contained in a nested data structure. * @param {Object} obj - Nested data structure * @param {string} path - Path to the property whose value is to be returned or changed. * @param {any} [value] - New value to be set. If not specified, the value of the property is returned. * @returns {any} - Existing or updated value of the property. * @example // Get value * const obj = { foo: { bar: [{ abc: \"xyz\" }] } }; * const result = ccm.helper.deepValue(obj, \"foo.bar.0.abc\"); * console.log(result); // =&gt; 'xyz' * @example // Set value * var obj = {}; * var result = ccm.helper.deepValue(obj, \"foo.bar\", \"abc\"); * console.log(obj); // =&gt; { foo: { bar: \"abc\" } } * console.log(result); // =&gt; \"abc\" */ deepValue: function (obj, path, value) { return recursive(obj, path.split(\".\"), value); function recursive(obj, key, value) { if (!obj) return; const next = key.shift(); if (key.length === 0) return value !== undefined ? (obj[next] = value) : obj[next]; if (!obj[next] &amp;&amp; value !== undefined) obj[next] = isNaN(key[0]) ? {} : []; return recursive(obj[next], key, value); } }, /** * @description Replaces placeholders in data with values (e.g. in a string or object). * @param {any} data * @param {Object} values * @returns {any} - Deep copy of data with replaced placeholders. * @example // Replace placeholders in a string * const string = \"Hello, %name%!\"; * const values = { name: \"World\" }; * const result = ccm.helper.format(string, values); * console.log(result); // =&gt; \"Hello, World!\" * @example // Replace placeholders in an object * const object = { hello: \"Hello, %name%!\" }; * const values = { name: \"World\" }; * const result = ccm.helper.format(object, values); * console.log(result); // =&gt; { hello: \"Hello, World!\" } */ format: (data, values) =&gt; { const functions = {}; // convert data to string (if not already) data = ccm.helper.stringify(data); // replace placeholders with values (functions are stored in a separate object) for (const key in values) if (typeof values[key] !== \"function\") data = data.replace( new RegExp(`%${key}%`, \"g\"), values[key].replace(/\"/g, '\\\\\"'), ); else functions[`%${key}%`] = values[key]; // convert the data back to its original format and return it (replace placeholders for functions) return ccm.helper.parse(data, (key, val) =&gt; Object.keys(functions).includes(val) ? functions[val] : val, ); }, /** * Converts HTML given as a string or JSON into HTML elements. * @param {string|html_data} html * @param {Object} values - Placeholders contained in the HTML are replaced by these values. * @param {Object} settings * @param {boolean} [settings.ignore_apps] - No evaluation of \\&lt;ccm-app&gt; tags. * @param {string} [settings.namespace_uri] - Namespace URI for HTML elements. * @returns {Element|Text} * @example // Converting an HTML string * const str = '&lt;p&gt;Hello, &lt;b&gt;%name%&lt;/b&gt;! &lt;button onclick=\"%click%\"&gt;&lt;/button&gt;&lt;/p&gt;'; * const values = { * name: \"World\", * click: () =&gt; console.log(\"click!\") * }; * const elem = ccm.helper.html(str, values); * document.body.appendChild(elem); * @example // Converting HTML data * const json = { * inner: [ * \"Hello, \", * { * inner: \"%name%\", * tag: \"b\", * }, * \"! \", * { * tag: \"button\", * onclick: \"%click%\", * }, * ], * tag: \"p\", * }; * const values = { * name: \"World\", * click: () =&gt; console.log(\"click!\") * }; * const elem = window.ccm.helper.html(json, values); * document.body.appendChild(elem); */ html: (html, values, settings = {}) =&gt; { // convert HTML to JSON html = ccm.helper.html2json(html); // HTML is a primitive value (e.g. a string)? =&gt; convert it to a text node if (!ccm.helper.isObject(html)) return document.createTextNode(html); // replace placeholders in the HTML with values, if given if (values) html = ccm.helper.format(html, values); // is a svg element? =&gt; set namespace URI if (html.tag === \"svg\") settings.namespace_uri = \"http://www.w3.org/2000/svg\"; // create HTML element const element = settings.namespace_uri ? document.createElementNS(settings.namespace_uri, html.tag || \"div\") : document.createElement(html.tag || \"div\"); // set attributes, inner HTML and event listeners delete html.tag; for (const key in html) { const value = html[key]; switch (key) { case \"async\": case \"autofocus\": case \"defer\": case \"disabled\": case \"ismap\": case \"multiple\": case \"required\": case \"selected\": if (value) element[key] = true; break; case \"checked\": if (value) { element[key] = true; element.setAttribute(key, \"\"); } break; case \"readonly\": if (value) element.readOnly = true; break; case \"inner\": if ( typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" ) element.innerHTML = value; else { const children = Array.isArray(value) ? value : [value]; children.forEach((child) =&gt; element.appendChild( // recursive call for each child ccm.helper.html(child, undefined, settings), ), ); } break; default: if (key.indexOf(\"on\") === 0 &amp;&amp; typeof value === \"function\") element.addEventListener(key.substring(2), value); else element.setAttribute(key, value); } } if (element.tagName.startsWith(\"CCM-\") &amp;&amp; !settings.no_evaluation) ccm.start( element.tagName === \"CCM-APP\" ? element.getAttribute(\"component\") : element.tagName.substring(4).toLowerCase(), ccm.helper.generateConfig(element), element, ); return element; }, html2json: (html) =&gt; { const json = { inner: [] }; if (typeof html === \"string\") { const template = document.createElement(\"template\"); template.innerHTML = html; html = template.content; } if (html instanceof DocumentFragment) { if (!html.children.length) return html.textContent; [...html.childNodes].forEach((child) =&gt; { if (child.nodeValue) { if (!child.nodeValue || child.nodeType === Node.COMMENT_NODE) child.parentNode.removeChild(child); } }); if (html.childNodes.length === 1) html = html.firstChild; } if (!ccm.helper.isElement(html)) return html; if (html.tagName) json.tag = html.tagName.toLowerCase(); if (json.tag === \"div\") delete json.tag; if (html.attributes) [...html.attributes].forEach( (attr) =&gt; (json[attr.name] = attr.value === \"\" &amp;&amp; attr.name !== \"value\" ? true : attr.value), ); [...html.childNodes].forEach((child) =&gt; { if (child.nodeType === Node.COMMENT_NODE) return child.parentNode.removeChild(child); if (child.nodeValue &amp;&amp; !child.parentElement?.closest(\"pre\")) child.nodeValue = child.nodeValue.replace(/\\s+/g, \" \"); if (ccm.helper.isElement(child) || child.nodeValue) json.inner.push( ccm.helper.isElement(child) ? ccm.helper.html2json(child) : child.textContent, ); }); if (!json.inner.length) delete json.inner; else if (json.inner.length === 1) json.inner = json.inner[0]; return json; }, isComponent: (value) =&gt; value?.Instance &amp;&amp; value.ccm &amp;&amp; true, isCore: (value) =&gt; value?.components &amp;&amp; value.version &amp;&amp; true, isDatastore: (value) =&gt; value?.get &amp;&amp; value.local &amp;&amp; value.source &amp;&amp; true, isElement: (value) =&gt; { return value instanceof Element || value instanceof DocumentFragment; }, isInstance: (value) =&gt; ccm.helper.isComponent(value?.component), isNode: (value) =&gt; value instanceof Node, isObject: (value) =&gt; { return value &amp;&amp; typeof value === \"object\" &amp;&amp; !Array.isArray(value); }, isSpecialObject: (value) =&gt; { return !!( value === window || ccm.helper.isNode(value) || ccm.helper.isCore(value) || ccm.helper.isInstance(value) || ccm.helper.isComponent(value) || ccm.helper.isDatastore(value) ); }, parse: (string, reviver) =&gt; { return JSON.parse( string .replace(/\\\\n/g, \"\\\\n\") .replace(/\\\\'/g, \"\\\\'\") .replace(/\\\\\"/g, '\\\\\"') .replace(/\\\\&amp;/g, \"\\\\&amp;\") .replace(/\\\\r/g, \"\\\\r\") .replace(/\\\\t/g, \"\\\\t\") .replace(/\\\\b/g, \"\\\\b\") .replace(/\\\\f/g, \"\\\\f\") .replace(/[\\u0000-\\u0019]+/g, \"\"), reviver, ); }, regex: (index) =&gt; { switch (index) { case \"filename\": return /^ccm\\.([a-z][a-z_0-9]*)(-(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*))?(\\.min)?(\\.js)$/; case \"key\": return /^[a-zA-Z0-9_-]+$/; case \"json\": return /^(({(.|\\n)*})|(\\[(.|\\n)*])|true|false|null)$/; } }, stringify: (value, replacer, space) =&gt; { return JSON.stringify( value, (key, value) =&gt; { if ( typeof value === \"function\" || ccm.helper.isSpecialObject(value) ) value = null; return replacer ? replacer(key, value) : value; }, space, ); }, }, }; // Is this the first ccmjs framework version loaded in this webpage? =&gt; Initialize global namespace. if (!window.ccm) window.ccm = { /** * @description * This namespace is only used internally. * JSONP callbacks for loading data via {@link ccm.load} are temporarily stored here (is always emptied directly). * @namespace ccm.callbacks * @type {Object.&lt;string,function&gt;} */ callbacks: {}, /** * @description * This namespace is only used internally. * Result data of loaded JavaScript files via {@link ccm.load} are temporarily stored here (is always emptied directly). * @namespace ccm.files * @type {Object} */ files: {}, }; // Is this the first time this specific ccmjs framework version is loaded in this webpage? =&gt; Initialize version specific namespace. if (!window.ccm[ccm.version()]) window.ccm[ccm.version()] = ccm; // Is this the latest ccmjs framework version loaded on this website so far? =&gt; Update global namespace. if ( !window.ccm.version || ccm.helper.compareVersions(ccm.version(), window.ccm.version()) &gt; 0 ) Object.assign(window.ccm, ccm); })(); /** * @namespace ccm.types * @description _ccmjs_-specific Type Definitions */ /** * @typedef {Object} ccm.types.resource_obj * @description * Instead of a URL, a resource object can be passed to the method {@link ccm.load}, which then contains other information besides the URL, via which the loading of the resource is even more flexible controllable. * In the case of HTML, JSON and XML, the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) is used to load the ressource. All properties in the resource object are also spread into the &lt;code&gt;options&lt;/code&gt; object (2nd parameter of [fetch()](https://developer.mozilla.org/en-US/docs/Web/API/fetch)). This means that, for example, HTTP headers can also be set here. * @property {string} url - URL from which the resource should be loaded. * @property {Element|ccm.types.instance} [context] - Context in which the resource is loaded (default is &lt;code&gt;\\&lt;head&gt;&lt;/code&gt;). Only relevant when loading CSS or JavaScript. CSS is loaded via &lt;code&gt;\\&lt;link&gt;&lt;/code&gt; and JavaScript is loaded via &lt;code&gt;\\&lt;script&gt;&lt;/code&gt;. When a [_ccmjs_ component instance]{@link ccm.types.instance} is passed, the resource is loaded in the Shadow DOM of that instance. * @property {string} [type] - Resource is loaded as &lt;code&gt;'css'&lt;/code&gt;, &lt;code&gt;'html'&lt;/code&gt;, &lt;code&gt;'image'&lt;/code&gt;, &lt;code&gt;'js'&lt;/code&gt;, &lt;code&gt;'module'&lt;/code&gt;, &lt;code&gt;'json'&lt;/code&gt; or &lt;code&gt;'xml'&lt;/code&gt;. If not specified, the type is automatically recognized by the file extension. If the file extension is unknown, &lt;code&gt;'json'&lt;/code&gt; is used by default. * @property {string} [attr] - Additional HTML attributes to be set for the HTML tag that loads the resource. Only relevant when loading CSS or JavaScript. CSS is loaded via &lt;code&gt;\\&lt;link&gt;&lt;/code&gt; and JavaScript is loaded via &lt;code&gt;\\&lt;script&gt;&lt;/code&gt;. With the additional attributes &lt;code&gt;integrity&lt;/code&gt; and &lt;code&gt;crossorigin&lt;/code&gt; the resource can be loaded with Subresource Integrity (SRI). * @property {string} [method] - The request method, e.g., &lt;code&gt;\"GET\"&lt;/code&gt;, &lt;code&gt;\"POST\"&lt;/code&gt;. The default is &lt;code&gt;\"GET\"&lt;/code&gt;. Only relevant when loading data. &lt;code&gt;\"JSONP\"&lt;/code&gt; is also supported. * @property {string} [params] - HTTP parameters to send. Only relevant when loading data. * @tutorial loading-of-resources */ /** * @typedef {string} ccm.types.version_nr * @description A version number that is conformed with Semantic Versioning 2.0.0 ({@link http://semver.org}). * @example \"1.0.0\" * @example \"2.1.3\" */ /** * @typedef {Object} ccm.types.instance */ × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespaces Namespaces ccm callbacks files helper types × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"index.html":{"id":"index.html","title":"Index","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types ccmjs Framework Framework of the ccmjs Web Technology. Index ccm.js Creates the global namespace window.ccm. Version: 28.0.0 Author: André Kless &lt;andre.kless@web.de&gt; (https://github.com/akless) 2014-2023 License: The MIT License (MIT) Source: ccm.js, line 3 × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"ccm.html":{"id":"ccm.html","title":"Namespace: ccm","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespace: ccm ccm Encapsulates everything related to ccmjs. See this wiki to learn everything about this web technology. Source: ccm.js, line 25 Namespaces callbacks files helper types Methods &lt;static&gt; load(resources) Asynchronous Loading of Resources See this wiki page to learn everything about this method. There are also examples how to use it. Parameters: Name Type Argument Description resources string | ccm.types.resource_obj &lt;repeatable&gt; Resources to load. Either the URL or a resource object can be passed for a resource. Source: ccm.js, line 38 Returns: Type Promise.&lt;*&gt; &lt;static&gt; version() Returns the ccmjs framework version. Source: ccm.js, line 30 Returns: Type ccm.types.version_nr × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"ccm.callbacks.html":{"id":"ccm.callbacks.html","title":"Namespace: callbacks","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespace: callbacks ccm. callbacks This namespace is only used internally. JSONP callbacks for loading data via ccm.load are temporarily stored here (is always emptied directly). Source: ccm.js, line 601 × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"ccm.files.html":{"id":"ccm.files.html","title":"Namespace: files","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespace: files ccm. files This namespace is only used internally. Result data of loaded JavaScript files via ccm.load are temporarily stored here (is always emptied directly). Source: ccm.js, line 610 × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"ccm.helper.html":{"id":"ccm.helper.html","title":"Namespace: helper","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespace: helper ccm. helper Contains framework-relevant helper functions. These are also useful for component developers. Source: ccm.js, line 288 Methods &lt;static&gt; compareVersions(a, b) Compares two version numbers. Parameters: Name Type Description a ccm.types.version_nr 1st version number b ccm.types.version_nr 2nd version number Source: ccm.js, line 297 Returns: -1: a &lt; b, 0: a = b, 1: a &gt; b Type number Examples console.log( compareVersions( '3.0.0', '2.10.0' ) ); // =&gt; 1 console.log( compareVersions( '8.0.1', '8.0.10' ) ); // =&gt; -1 &lt;static&gt; deepValue(obj, path [, value]) Returns or modifies a value contained in a nested data structure. Parameters: Name Type Argument Description obj Object Nested data structure path string Path to the property whose value is to be returned or changed. value any &lt;optional&gt; New value to be set. If not specified, the value of the property is returned. Source: ccm.js, line 328 Returns: Existing or updated value of the property. Type any Examples // Get value const obj = { foo: { bar: [{ abc: \"xyz\" }] } }; const result = ccm.helper.deepValue(obj, \"foo.bar.0.abc\"); console.log(result); // =&gt; 'xyz' // Set value var obj = {}; var result = ccm.helper.deepValue(obj, \"foo.bar\", \"abc\"); console.log(obj); // =&gt; { foo: { bar: \"abc\" } } console.log(result); // =&gt; \"abc\" &lt;static&gt; format(data, values) Replaces placeholders in data with values (e.g. in a string or object). Parameters: Name Type Description data any values Object Source: ccm.js, line 357 Returns: Deep copy of data with replaced placeholders. Type any Examples // Replace placeholders in a string const string = \"Hello, %name%!\"; const values = { name: \"World\" }; const result = ccm.helper.format(string, values); console.log(result); // =&gt; \"Hello, World!\" // Replace placeholders in an object const object = { hello: \"Hello, %name%!\" }; const values = { name: \"World\" }; const result = ccm.helper.format(object, values); console.log(result); // =&gt; { hello: \"Hello, World!\" } &lt;static&gt; html(html, values, settings) Converts HTML given as a string or JSON into HTML elements. Parameters: Name Type Description html string | html_data values Object Placeholders contained in the HTML are replaced by these values. settings Object Properties Name Type Argument Description ignore_apps boolean &lt;optional&gt; No evaluation of &lt;ccm-app&gt; tags. namespace_uri string &lt;optional&gt; Namespace URI for HTML elements. Source: ccm.js, line 417 Returns: Type Element | Text Examples // Converting an HTML string const str = '&lt;p&gt;Hello, &lt;b&gt;%name%&lt;/b&gt;! &lt;button onclick=\"%click%\"&gt;&lt;/button&gt;&lt;/p&gt;'; const values = { name: \"World\", click: () =&gt; console.log(\"click!\") }; const elem = ccm.helper.html(str, values); document.body.appendChild(elem); // Converting HTML data const json = { inner: [ \"Hello, \", { inner: \"%name%\", tag: \"b\", }, \"! \", { tag: \"button\", onclick: \"%click%\", }, ], tag: \"p\", }; const values = { name: \"World\", click: () =&gt; console.log(\"click!\") }; const elem = window.ccm.helper.html(json, values); document.body.appendChild(elem); × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "},"ccm.types.html":{"id":"ccm.types.html","title":"Namespace: types","body":" ccmjs Namespaces ccmccm.callbacksccm.filesccm.helperccm.types Namespace: types ccm. types ccmjs-specific Type Definitions Source: ccm.js, line 631 Type Definitions instance Type: Object Source: ccm.js, line 657 resource_obj Instead of a URL, a resource object can be passed to the method ccm.load, which then contains other information besides the URL, via which the loading of the resource is even more flexible controllable. In the case of HTML, JSON and XML, the Fetch API is used to load the ressource. All properties in the resource object are also spread into the options object (2nd parameter of fetch()). This means that, for example, HTTP headers can also be set here. Type: Object Properties: Name Type Argument Description url string URL from which the resource should be loaded. context Element | ccm.types.instance &lt;optional&gt; Context in which the resource is loaded (default is &lt;head&gt;). Only relevant when loading CSS or JavaScript. CSS is loaded via &lt;link&gt; and JavaScript is loaded via &lt;script&gt;. When a ccmjs component instance is passed, the resource is loaded in the Shadow DOM of that instance. type string &lt;optional&gt; Resource is loaded as 'css', 'html', 'image', 'js', 'module', 'json' or 'xml'. If not specified, the type is automatically recognized by the file extension. If the file extension is unknown, 'json' is used by default. attr string &lt;optional&gt; Additional HTML attributes to be set for the HTML tag that loads the resource. Only relevant when loading CSS or JavaScript. CSS is loaded via &lt;link&gt; and JavaScript is loaded via &lt;script&gt;. With the additional attributes integrity and crossorigin the resource can be loaded with Subresource Integrity (SRI). method string &lt;optional&gt; The request method, e.g., \"GET\", \"POST\". The default is \"GET\". Only relevant when loading data. \"JSONP\" is also supported. params string &lt;optional&gt; HTTP parameters to send. Only relevant when loading data. Source: ccm.js, line 636 Tutorials: Tutorial: loading-of-resources version_nr A version number that is conformed with Semantic Versioning 2.0.0 (http://semver.org). Type: string Source: ccm.js, line 650 Examples \"1.0.0\" \"2.1.3\" × Search results Close This Documentation is written by the Developer of the ccmjs framework: André Kless "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
